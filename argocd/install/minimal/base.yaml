# =========================================================
# Argo CD - Minimal Install (Core only)
# Components: server, repo-server, application-controller, redis
# CRDs: Application, AppProject
# No: dex, notifications, applicationset, extra use-cases
# =========================================================





apiVersion: v1                                          # Standard API für Namespaces
kind: Namespace                                         # Isolierter Bereich im Cluster
metadata:                                               
  name: argocd                                  # Name des neuen "Ordners" im Cluster
  labels:                                               # zusätzliche Markierungen
    app.kubernetes.io/name: argocd                      # Hilft Tools, diese Ressource ArgoCD zuzuordnen
---
# -----------------------------
# CRD: AppProject
# -----------------------------
apiVersion: apiextensions.k8s.io/v1                     # Schnittstelle, um Kubernetes neue Objekttypen beizubringen
kind: CustomResourceDefinition                          # Wir definieren hier ein "Plugin" für die K8s-API
metadata:
  name: appprojects.argoproj.io                         # Der eindeutige Name dieses neuen Typs
spec:
  group: argoproj.io                                     
  scope: Namespaced                                     
  names:
    plural: appprojects
    singular: appproject
    kind: AppProject
    shortNames:
      - appproj
  versions:                                               # Versionen die dieser Objekttyp unterstützt (CRD)
    - name: v1alpha1
      served: true                                        # Bestimmt ob diese Version über die Kubernetes-API erreichbar sein soll
      storage: true                                       # Legt fest, dass diese Version diejenige ist, in der die Daten in der Datenbank (etcd) gespeichert werden
      subresources:
        status: {}                                        # Aktiviert das Feld ".status", das separat vom ".spec" aktualisiert werden kann (Status einer App ändern, ohne die Erlaubnis spec zu ändern)
      schema:                                             # Definiert die Struktur des CRD (Bauplan)
        openAPIV3Schema:
          type: object                                    # Das Wurzel-Element des Objekts muss ein JSON/YAML-Objekt sein (keine Liste oder Text)
          x-kubernetes-preserve-unknown-fields: true
---
# -----------------------------
# CRD: Application
# -----------------------------
apiVersion: apiextensions.k8s.io/v1                     # API Version für neue Objekttypen (CustomResourceDefinition)
kind: CustomResourceDefinition                          # Definiert neuen Objekttypen für Kubernetes
metadata:
  name: applications.argoproj.io                        # Name des neuen Typs "Application"
spec:
  group: argoproj.io                                    # Gruppe des neuen Objekttypen
  scope: Namespaced                                     # Application existiert nur innerhalb des Namespaces  
  names:                                                # Name für den Zugriff
    plural: applications                                # Plural für kubectl (z.B. kubectl get applications)
    singular: application
    kind: Application                                   # Name, den man im YAML verwendet    
    shortNames:
      - app 
  versions:
    - name: v1alpha1
      served: true
      storage: true
      subresources:
        status: {}
      schema:
        openAPIV3Schema:
          type: object
          x-kubernetes-preserve-unknown-fields: true    # ArgoCD erlaubt es, dass man unerwartete Felder in der YAML verwendet
---
# -----------------------------
# ServiceAccounts
# -----------------------------
# Ein ServiceAccount ist wie ein "Benutzerkonto" oder "Personalausweis" für Programme
# Damit kann sich ein Pod gegenüber der Kubernetes-API ausweisen
apiVersion: v1
kind: ServiceAccount
metadata:
  name: argocd-server
  namespace: argocd
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: argocd-repo-server
  namespace: argocd
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: argocd-application-controller
  namespace: argocd
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: argocd-redis
  namespace: argocd
---
# -----------------------------
# RBAC: Wer darf was?
# (Minimalistisches aber praktisches Set für Lernzwecke)
# -----------------------------
apiVersion: rbac.authorization.k8s.io/v1          # API für Rollen und Rechte
kind: ClusterRole                                 # Die "Stellenbeschreibung": WAS darf man tun? (Cluster-weit)
metadata:
  name: argocd-application-controller
rules:
  # Full access to core resources that ArgoCD manages
  - apiGroups: ["", "apps", "batch", "extensions", "networking.k8s.io"]
    resources: ["*"]
    verbs: ["*"]
  # Full access to ArgoCD CRDs
  - apiGroups: ["argoproj.io"] 
    resources: ["applications", "appprojects"]
    verbs: ["*"]
  # Read-only access to all other API groups (for cluster state caching)
  - apiGroups: ["*"]
    resources: ["*"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1       
kind: ClusterRoleBinding                          # Die "Zuweisung": WER bekommt die Stelle?
metadata:
  name: argocd-application-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: argocd-application-controller
subjects:
  - kind: ServiceAccount
    name: argocd-application-controller
    namespace: argocd
---
# Server & repo-server can live with namespaced RBAC (dev-minimal)
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: argocd-server
  namespace: argocd
rules:
  - apiGroups: [""]
    resources: ["secrets", "configmaps", "events", "pods", "pods/log"]
    verbs: ["get", "list", "watch", "create", "patch", "update"]
  - apiGroups: ["argoproj.io"]
    resources: ["applications", "appprojects"]
    verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
---
apiVersion: rbac.authorization.k8s.io/v1 
kind: RoleBinding
metadata:
  name: argocd-server
  namespace: argocd
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: argocd-server
subjects:
  - kind: ServiceAccount
    name: argocd-server
    namespace: argocd
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: argocd-repo-server
  namespace: argocd
rules:
  - apiGroups: [""]
    resources: ["secrets", "configmaps"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: argocd-repo-server
  namespace: argocd
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: argocd-repo-server
subjects:
  - kind: ServiceAccount
    name: argocd-repo-server
    namespace: argocd
---
# -----------------------------
# Redis (minimal)
# -----------------------------
apiVersion: apps/v1                               # Standard API für Deployments
kind: Deployment                                  # Definiert ein Deployment, sagt Kubernetes "Lass dieses Programm laufen"
metadata:
  name: argocd-redis                              # Name des Programms (Cache für ArgoCD)
  namespace: argocd                       # Namespace, in dem das Deployment läuft
  labels:
    app.kubernetes.io/name: argocd-redis       
spec:                                             # wie solls laufen?
  replicas: 1                                     # Anzahl der Instanzen (Pods)
  selector:                                       # wie Kubernetes die Instanzen finden soll
    matchLabels:                                  # Suchkriterium
      app.kubernetes.io/name: argocd-redis        # finde Pods mit diesem Label
  template:                                       # Bauplan für neue Pods
    metadata:
      labels:
        app.kubernetes.io/name: argocd-redis      # Label, nach dem oben gesucht wird
    spec:
      serviceAccountName: argocd-redis            # ServiceAccount, der für das Deployment verwendet wird
      containers:                                 # Docker-Container, die im Pod laufen
        - name: redis
          image: redis:7-alpine                   # Docker-Image, das verwendet wird (kleine, schnelle Version)
          ports:
            - containerPort: 6379                 # Port, auf dem der Container läuft
          resources:
            requests:
              cpu: 50m
              memory: 64Mi
            limits:
              cpu: 500m
              memory: 256Mi
---
apiVersion: v1                                    # Standard API für Services
kind: Service   
metadata:
  name: argocd-redis
  namespace: argocd
spec:                                             
  ports:
    - name: redis
      port: 6379
      targetPort: 6379
  selector:
    app.kubernetes.io/name: argocd-redis          # finde Pods mit diesem Label
---
# -----------------------------
# Repo Server
# -----------------------------
apiVersion: apps/v1                               
kind: Deployment                                  
metadata:
  name: argocd-repo-server
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-repo-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: argocd-repo-server
  template:
    metadata:
      labels:
        app.kubernetes.io/name: argocd-repo-server
    spec:
      serviceAccountName: argocd-repo-server
      containers:
        - name: argocd-repo-server
          # Pick a version you use in the company; keep pinned
          image: quay.io/argoproj/argocd:v2.10.3
          imagePullPolicy: IfNotPresent
          args:
            - argocd-repo-server
            - --redis
            - argocd-redis:6379
          ports:
            - containerPort: 8081
          readinessProbe:                         # "Gesundheitscheck": Ist das Programm bereit für Besucher?
            tcpSocket:
              port: 8081
            initialDelaySeconds: 5                # Warte 5s nach dem Start
            periodSeconds: 10                     # Alle 10s erneut prüfen
          resources:
            requests:
              cpu: 100m
              memory: 256Mi
            limits:
              cpu: 1000m
              memory: 1Gi
---
apiVersion: v1
kind: Service
metadata:
  name: argocd-repo-server
  namespace: argocd
spec:
  ports:
    - name: https
      port: 8081
      targetPort: 8081
  selector:
    app.kubernetes.io/name: argocd-repo-server
---
# -----------------------------
# Application Controller
# -----------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: argocd-application-controller
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-application-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: argocd-application-controller
  template:
    metadata:
      labels:
        app.kubernetes.io/name: argocd-application-controller
    spec:
      serviceAccountName: argocd-application-controller
      containers:
        - name: argocd-application-controller
          image: quay.io/argoproj/argocd:v2.10.3
          imagePullPolicy: IfNotPresent
          args:
            - argocd-application-controller
            - --repo-server
            - argocd-repo-server:8081
            - --redis
            - argocd-redis:6379
          env:
            - name: ARGOCD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          resources:
            requests:
              cpu: 200m
              memory: 512Mi
            limits:
              cpu: 2000m
              memory: 2Gi
---
# -----------------------------
# Argo CD Server (API + UI)
# -----------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  name: argocd-server
  namespace: argocd
  labels:
    app.kubernetes.io/name: argocd-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: argocd-server
  template:
    metadata:
      labels:
        app.kubernetes.io/name: argocd-server
    spec:
      serviceAccountName: argocd-server
      containers:
        - name: argocd-server
          image: quay.io/argoproj/argocd:v2.10.3
          imagePullPolicy: IfNotPresent
          args:
            - argocd-server
            - --redis
            - argocd-redis:6379
            # For local/dev you can run insecure and port-forward
            # In production: use TLS / ingress and remove this
            - --insecure
          ports:
            - name: http
              containerPort: 8080
          env:
            - name: ARGOCD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
          resources:
            requests:
              cpu: 100m
              memory: 256Mi
            limits:
              cpu: 1500m
              memory: 1Gi
---
apiVersion: v1                                    # Standard API für Netzwerk-Dienste
kind: Service                                     # Erstellt eine feste Adresse für die Pods
metadata:
  name: argocd-server                             # Name der Adresse
  namespace: argocd                       # Namespace, in dem die Adresse gilt
spec:
  type: ClusterIP                                 # Service-Typ, ClusterIP ist standard
  ports:                                          # Ports, die weitergeleitet werden
    - name: http                                  # Name des Ports
      port: 80                                    # Port, der für die Adresse verfügbar ist
      targetPort: 8080                            # Port, der für die Pods verfügbar ist
  selector:                                       # Welche Pods sollen unter dieser Adresse erreichbar sein?
    app.kubernetes.io/name: argocd-server         # Alle Pods mit Label "argocd-server"
---
# -----------------------------
# Argo CD Secret (Required)
# -----------------------------
apiVersion: v1                                    # Standard API für Secrets
kind: Secret                                      # Erstellt ein Secret
metadata:
  name: argocd-secret
  namespace: argocd
type: Opaque
data:
  # This is a placeholder; in a real install, this would be generated
  admin.password: ""
  admin.passwordMtime: ""
  server.secretkey: ""

